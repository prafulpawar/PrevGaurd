import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import api from '../../services/api'; // Assuming api is configured (e.g., Axios instance)

// Define the initial state
const initialState = {
    emailData: '',   // The email input value
    isLoading: false, // Flag for loading state during API call
    error: null,     // To store potential error messages
    data: null,      // To store the breach data received from API
};

// Async thunk for fetching breach data
export const fetchBreachData = createAsyncThunk(
    'breach/fetch', // Action type prefix (convention: sliceName/actionName)
    async (email, { rejectWithValue }) => { // Receive email as argument when dispatching
        // Check if email is provided (optional, but good practice)
        if (!email) {
            return rejectWithValue('Email is required');
        }
        try {
            // Make GET request with email as a query parameter
            const response = await api.get('/api/breach/check', {
                params: { email: email }, // Correct way to send query params with Axios GET
                // No need for Content-Type header for GET usually
            });
            // Return the data part of the response on success
            return response.data;
        } catch (error) {
            // Log the error for debugging
            console.error("API Error fetching breach data:", error);
            // Use rejectWithValue to pass a specific error payload (e.g., server message or default)
            // Ensure a serializable value is returned
            const errorMessage = error.response?.data?.message || error.message || 'Error In Getting Data';
            return rejectWithValue(errorMessage);
        }
    }
);

// Create the Redux slice
const breachSlice = createSlice({
    name: 'breach', // Name of the slice
    initialState,   // Initial state defined above
    reducers: {
        // Action to update the email value in the state
        updateEmailValue: (state, action) => {
            state.emailData = action.payload;
            // Reset status when email changes, preparing for a new potential fetch
            state.isLoading = false;
            state.error = null;
            state.data = null; // Clear previous data
        },
        // Action to reset the entire slice state to initial values
        resetBreachState: () => initialState, // Use a more descriptive name
    },
    // Handle actions defined outside the slice (like async thunks)
    extraReducers: (builder) => {
        builder
            // Case for when the async thunk starts
            .addCase(fetchBreachData.pending, (state) => {
                state.isLoading = true;
                state.error = null; // Clear previous errors
                state.data = null; // Clear previous data
            })
            // Case for when the async thunk succeeds
            .addCase(fetchBreachData.fulfilled, (state, action) => {
                state.isLoading = false;
                state.data = action.payload; // Store the received data
                state.error = null; // Clear any previous error
            })
            // Case for when the async thunk fails
            .addCase(fetchBreachData.rejected, (state, action) => {
                state.isLoading = false;
                // Store the error message from rejectWithValue
                state.error = action.payload;
                state.data = null; // Clear data on error
            });
    },
});

// Export the action creators generated by createSlice
export const { updateEmailValue, resetBreachState } = breachSlice.actions;

// Selectors to access parts of the state
export const selectBreachEmail = (state) => state.breach.emailData;
export const selectBreachData = (state) => state.breach.data;
export const selectBreachIsLoading = (state) => state.breach.isLoading;
export const selectBreachError = (state) => state.breach.error;
export const selectEntireBreachState = (state) => state.breach; // Selector for the whole slice state

// Export the reducer function for the store configuration
export default breachSlice.reducer;